

ETAPE 1 : Créer un graph à partir d'un repo. (OK !)

But : à partir d'un dossier, être capable de créer un graph représentant tous les fichier ainsi que toutes les relations entre ces fichiers.




1) Ecrire une fonction qui récupère récursivement le nom entier de tous les fichiers d'un dossier (avec chemin d'accès) (OK)
	Ne garder que les fichiers PHP. (OK)

2) Créer une classe Node, dont les objets seront les noeuds du graph. 
Cette classe aura comme attribut les propriétés que devront avoir les noeuds du graph. (OK)
Constructeur : 
	prend comme paramètre le chemin d'accès au fichier, et sera capable de remplir les autres propriétés. (OK)
Methodes : 
	- Générer une requête Cypher qui ajoutera le noeud à la base (OK)
	- Retourner les lignes qui comportent des include ou require (OK)
	- En déduire les chemins d'accès complets des fichiers inclus (OK)
		DIFFICULTES : 
			- Le fichier peut être inclu par include, require, include_once ou require_once
			- Des parenthèses peuvent (ou non) être utilisées -> require fichier.php = require(fichier.php)
			- Le chemin peut être aboslu ou relatif
			- Des variables ou constantes peuvent être (ou non) utilisées pour inclure les fichiers
			- Ces variables ou constantes peuvent valoir l'intégralité du chemin d'accès vers le fichier ou seulement une partie
			- Dans un fichier lui même inclu dans un autre, le chemin d'accès (si relatif) est relatif au parent et non au fichier lui même
		SOLUTIONS / STRATEGIE D'IDENTIFICATION DES DEPENDANCES : 
			- On parcours le fichier ligne à ligne. Pour chaque ligne : 
			- Si le code php de la ligne commence par include ou require, il y a une dépendence. On garde la ligne : 
				- On recherche la présence de variable dans cette ligne. Si il y en a : 
					- Identification du nom de la variable
					- Identification de la valeur de la variable en reparcourant le fichier, à la recherche de la déclaration de la variable
					- Dans la ligne, on remplace la variable par a valeur et on l'entoure de guillemets. 
				- On élimine tout ce qui n'est pas entouré de simple ou doubles quotes (statements include, parenthèses, guillets, opérateurs de concaténation)
				- On remplace les parties ../ et ./ du path par les noms de dossiers correspondant.
	- Générer une requête qui identifiera ces fichiers, et créera une relation avec dans la base (OK)


3) Créer un programme qui créera la base de données
	- Créer une base de données neo4j et s'y connecter (OK)
	- Analyser un repo et créer un objet Node pour chaque repo (OK)
	- Créer tous les Nodes dans la base (OK)
	- Identifier toutes les inclusions entre les fichiers et les créer dans la base de données (OK)


Améliorations de l'étape 1 à faire avant de continuer : 
- Réfléchir à séparer les fonctions d'aide à getDependencies() de la classe Node (OK -> mauvaise idée)
- Rendre la date de modification des fichiers humainement compréhensible (OK)
- Améliorer un peu l'architecture du repo (OK)
- Distinguer les include des require dans la modélisation (OK)
- Avancer un peu dans le rapport (OK)
- Indiquer le path par rapport au repo et non par rapport à la racine du système hôte (OK)
- Prendre en compte que les chemins d'accès peuvent contenir la constante magique __DIR__, qu'il faudra donc remplacer par le chemin d'accès correspondant (OK)










ETAPE 2 : Ajouter les features au graph (OK !)

Il va ici s'agir de trouver les fichiers en tête de l'arborescence des dépendences. Ces fichiers devront être reliés à une ou plusieurs features. 

But : Pour n'importe quel fichier modifié, on doit pouvoir parcourir les relations du graph, trouver tous les fichiers dans lesquels ce fichier est inclu, et finalement identifier toutes les features potentiellement impactées par ce fichier.


--> PHASE DE TEST
1) Créer un nouveau programme. Il doit pouvoir se connecter à la base de données, et renvoyer la liste des fichiers qui ne sont inclus dans aucun autre fichier. (OK)
	- Depuis le repo de test, identifier à l'aide de ce programme l'ensemble des fichiers auquel il faut associer une feature (OK)
		-> Ecrire une requête qui sort tous les noeuds qui ne pointent vers aucun autre noeuds avec une relation IS_INCLUDED_IN ni IN_REQUIRED_IN. (OK)
	- Imaginer une syntaxe à inscrire dans l'en-tête de chacun de ces fichiers afin d'annoter rapidement et clairement leur(s) feature(s) (OK)
	- Annoter ainsi les fichiers (OK)
	=> Ce programme ne sera utile qu'une fois. Il permettra aux developpeurs de savoir quels fichiers annoter. Une fois les fichiers annotés, il faudra prendre 
		l'habitude d'annoter chaque nouveau fichier, afin d'être toujours à jour au niveau des liens fichier->feature.


2) Dans le programme initial index.php :
	- ajouter dans la première boucle (celle qui envoie les fichiers sans relations dans la base) l'envoie d'un noeud par feature dans la base (ANNULE)
	- ajouter dans cette même boucle l'envoie des relations entre les fichiers et leur(s) feature(s) dans la base (ANNULE)
	COMMENT FAIRE ?
		- Dans la classe Node.php, ajouter un attribut features de type array qui stockera les features impactées par ce fichier (OK)
		- Préparer une méthode qui génèrera une requête d'ajout d'un noeud par feature, puis une requête d'ajoute de toutes les relations entre le fichier et ses features (ANNULE)
	Autre solution : 
		-> Dans le constructeur de Node, ajouter une méthode qui parcours les fichiers et va récupérer la liste des features listéees en commentaire au début de ces derniers. (OK)
		-> Dans la méthode generateUploadQuery, qui jusqu'ici ajoutait uniquement les noeuds sans relation, ajouter l'envoi des features dans la base de données, ainsi que les relations entre
			les fichiers et leur features. (OK)







ETAPE 3 : Revisiter l'architecture du programme. (OK !)

Comme expliqué dans le fichier subject.odt, il fallait revisiter la classe Node afin qu'elle stocke tous les éléments essentiels du programme dans ses attributs.
	
Lidée est, lors de la création d'un objet Node par fichier, de ne pas seulement utiliser cet objet pour préparer des requêtes Cypher puis le supprimer, mais de conserver ces objets, et de stocker dedans la liste des fichiers inclus, etc.
	-> nouveaux attributs : _features, _includes, _requires
	-> pour _path, _inlcudes et _requires, ce sont les path absolus des fichiers qui sont stockés. Ainsi, depuis un objet Node (dont l'attribut path est nécessairement unique), on peut trouver ceux dont le path correspond aux valeurs de l'attribut _includes, et ainsi parcourir ces objets à la manière d'un arbre.








ETAPE 4 : Prendre en compte les inclusions par namespaces. (OK !)

Il a d'abord fallu apprendre les notions de namespace en php. Une classe, une variable ou une fonction peuvent être identifées de manière unique par leur nom précédé de leur namespace. Cela permettra par exemple de dissocier la fonction sizeof() du namespace global (fonction définie par php) de la fonction My\Namespace\sizeof() définie par les développeurs dans le namespace My\Namespace

	- D'abord, modifier la classe Node afin que, lors du premier parcours du fichier (analyse), les namespaces et les alias (use) déclarés soient stockés dans les attributs de l'objet. (OK)
	- Dans la méthode generateUploadQuery, ajouter quelques lignes afin d'envoyer également les namespaces déclarés et de créer les relations entre fichiers et namespaces (comme pour l'étape 2) (OK)
	- Pour les alias use, il faut séparer le nom du namespace du nom de la classe aliassée. (OK)
	
	- Ensuite, dans le programme principal, dans la seconde boucle qui se charge d'uploader les relations dans la bdd, il faut ajouter toutes les relations USE
		- D'abord, pour chaque use, vérifier si le namespace aliassé existe dans la bdd (!!!REQUETE A ENVOYER)
			- Si oui, on tisse la relation
			- Si non, On crée un namespace avec un attribut supplémentaire "non-declared" valant True, puis on tisse la relation.
	- Problème : Tout ce code dans le programme principal est très mauvais, mais on ne peut pas demander à la classe Node d'effectuer des requetes a la base de donnée : elle doit suelement les générer.
	- SOLUTION : Créer une classe Use (TRES MAUVAISE IDEE)
		- L'attribut de Node _uses sera un array de Use
		- Les objets Use possèderont des méthodes de génération de requêtes : une pour vérifier si le namespace existe dans la base, et une pour créer les relation
		- Le constructeur de l'objet Use prendra en paramètre le chemin d'accès complet du namespace + classe et se chargera tous seul de spliter les éléments.
	- MEILLEURE SOLUTION (OK)
		- Au lieu d'indiquer explicitement dans le graph les Namespaces qui ne sont pas déclarés, on peut juste faire comme si ne rien n'était.
			-> On ajoute les relations IS_USED_BY entre les namespaces et les fichiers sans vérifier si le namespace existe déjà dans la base (on matche le NS avec la clause MERGE)
		- Par la suite, on pourra déceler les namespaces orphelins très simplement, car aucun fichier n'aura de relation DECLARES pointant sur lui.
		- Ainsi, il suffit de reprendre les méthodes generateIncludeRelationQuery et generateRequireRelationQuery et de les adapter aux relations des use.
		- Au cas ou ça serve à un moment, on stocke les classes aliassées par le use dans les propriétés de la relation, sous la forme d'un tableau de String
	- A prendre en compte, que, si un use ne comporte qu'un item dans son paramètre (ex: use Exception;), alors il réfère à une classe du namespace global. Il ne faut donc pas l'inclure dans la modélisation 







ETAPE 5 : Ajouter des index et des constraints au graph (petite étape)

Il faudra d'abord lire attentivement la documentation afin de comprendre ce que sont les index, et pourquoi peuvent ils être intéressants et utiles.







ETAPE 6 : Commencer à préparer des requêtes qui sortiront des éléments intéressants du graph : 
	-> Les fichiers orphelins
	-> Les éléments en tête d'architecture
	-> Les fichiers impactées par un fichier donné





AUTRES ETAPES : 
	Le problème avec ce projet d'analyse statique de code est qu'en fonction des fichiers/repository testés, on rencontre de nouveaux cas particuliers à prendre en compte. 
	Cette étape est donc réalisée au fur et à mesure que ces exceptions se rencontrent.
	Par exemple : 
		- Il peut y avoir des () autour des include -> à détecter puis supprimer
		- la constante __DIR__ peut être utilisée dans un chemin d'accès -> à remplacer par le chemin d'accès jusqu'au dossier dans lequel se trouve le fichier en cours d'analyse.
		- le pattern dirname(__FILE__) est équivent à la constante précédente
		- les variables dans les arguments des include peuvent être multiples -> a prendre en compte pour toutes les remplacer
		- ces variables peut être séparées par des opérateurs de concaténation, mais peuvent aussi être dans une chaine (ex: inlcude "machin/$var/machin") -> a prendre en compte également
		- Les variables peuvent être des variables de php (ex: $_SERVER['kjdd']) -> impossible à prendre en ocmpte car je n'exécute pas le code, mais il faut indiquer quelque part que ce include n'est pas pris en compte dans la mdélisation.
		- Les variables peuvent être des attributs d'un objet $objet->_attribut, auquel cas rechercher la déclaration devient plus compliquée.









PROJETS

- Améliorer le code qui parcours les fichiers à la recherche d'include et de variables : structure en arbre pour le parcourir plus rapidement (OK -> etape 3)
- Récupérer directement le repo depuis github (annulé : voir éventuellement à la fin du projet pour rajouter une surcouche (script bash) qui fera le clone puis lancera le php)
- Avant le début du scan d'un repo, effectuer un phploc sur le dossier (pour le fun ?)
- Lors de requêtes SQL vers une base, modéliser les relations entre les fichiers et cette base de données
- Ajouter les features à la modélisation (but premier) (OK -> etape 2)
- Ajouter les releases à la modélisation (Node : propriétés : date de début / fin, repo, et si la release est déployée ou non ou date de déploiement ?? Les nodes release pointeront par exemple sur les fichiers qui ont été modifiés durant l'itération) --> A REFLECHIR





AUTRE ETAPES : 
Créer un programme qui proposera des requêtes génériques :
	- Sortir les fichiers modifiés entre telle et telle date
	- Sortir tous les fichiers impactés par tel fichier 
	- etc ???



